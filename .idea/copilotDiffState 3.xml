<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/AudioPlayer.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/AudioPlayer.cpp" />
              <option name="originalContent" value="#include &quot;../include/AudioPlayer.h&quot;&#10;&#10;#include &lt;Arduino.h&gt;&#10;#include &lt;SD_MMC.h&gt;&#10;#include &quot;driver/i2s.h&quot;&#10;&#10;static TaskHandle_t audioTaskHandle = nullptr;&#10;static File audioFile;&#10;static volatile bool audioStopRequested = false;&#10;static volatile bool audioIsPlaying = false;&#10;&#10;static bool parseWavHeader(File &amp;f, uint32_t &amp;sampleRate, uint16_t &amp;bitsPerSample, uint16_t &amp;channels, uint32_t &amp;dataOffset, uint32_t &amp;dataSize) {&#10;  // Minimal WAV header parsing&#10;  if (!f) return false;&#10;  f.seek(0);&#10;  char riff[4];&#10;  f.read((uint8_t *)riff, 4);&#10;  if (strncmp(riff, &quot;RIFF&quot;, 4) != 0) return false;&#10;  f.seek(8);&#10;  char wave[4];&#10;  f.read((uint8_t *)wave, 4);&#10;  if (strncmp(wave, &quot;WAVE&quot;, 4) != 0) return false;&#10;&#10;  // Find chunks&#10;  dataOffset = 0;&#10;  dataSize = 0;&#10;  sampleRate = 44100;&#10;  bitsPerSample = 16;&#10;  channels = 1;&#10;&#10;  while (f.position() &lt; f.size()) {&#10;    char chunkId[5] = {0};&#10;    if (f.read((uint8_t *)chunkId, 4) != 4) break;&#10;    uint32_t chunkSize = 0;&#10;    if (f.read((uint8_t *)&amp;chunkSize, 4) != 4) break;&#10;&#10;    if (strncmp(chunkId, &quot;fmt &quot;, 4) == 0) {&#10;      uint16_t audioFormat = 0;&#10;      f.read((uint8_t *)&amp;audioFormat, 2);&#10;      f.read((uint8_t *)&amp;channels, 2);&#10;      f.read((uint8_t *)&amp;sampleRate, 4);&#10;      // skip byte rate(4) and block align(2)&#10;      f.seek(f.position() + 6);&#10;      f.read((uint8_t *)&amp;bitsPerSample, 2);&#10;      // skip any extra fmt bytes&#10;      uint32_t remain = chunkSize - 16;&#10;      if (remain &gt; 0) f.seek(f.position() + remain);&#10;    } else if (strncmp(chunkId, &quot;data&quot;, 4) == 0) {&#10;      dataOffset = f.position();&#10;      dataSize = chunkSize;&#10;      // move to end of data chunk start (we already at start of data)&#10;      f.seek(f.position() + chunkSize);&#10;    } else {&#10;      // skip unknown chunk&#10;      f.seek(f.position() + chunkSize);&#10;    }&#10;  }&#10;&#10;  // basic validation&#10;  if (dataOffset == 0 || dataSize == 0) return false;&#10;  return true;&#10;}&#10;&#10;static void stopI2S() {&#10;  i2s_zero_dma_buffer(I2S_NUM_0);&#10;  i2s_driver_uninstall(I2S_NUM_0);&#10;}&#10;&#10;static void audioTask(void *arg) {&#10;  uint32_t sampleRate = *(uint32_t *)arg; // passed in&#10;  free(arg);&#10;&#10;  const size_t bufferSize = 1024;&#10;  uint8_t buffer[bufferSize];&#10;&#10;  audioIsPlaying = true;&#10;  audioStopRequested = false;&#10;&#10;  while (!audioStopRequested &amp;&amp; audioFile &amp;&amp; audioFile.available()) {&#10;    size_t toRead = min((size_t)audioFile.available(), bufferSize);&#10;    int readBytes = audioFile.read(buffer, toRead);&#10;    if (readBytes &lt;= 0) break;&#10;&#10;    // Write to I2S&#10;    size_t bytesWritten = 0;&#10;    esp_err_t res = i2s_write(I2S_NUM_0, buffer, readBytes, &amp;bytesWritten, portMAX_DELAY);&#10;    if (res != ESP_OK) break;&#10;  }&#10;&#10;  audioFile.close();&#10;  stopI2S();&#10;  audioIsPlaying = false;&#10;  audioTaskHandle = nullptr;&#10;  vTaskDelete(NULL);&#10;}&#10;&#10;bool audioInit() {&#10;  // nothing to init ahead of time; SD will be initialized in main&#10;  return true;&#10;}&#10;&#10;bool playFile(const char *path) {&#10;  if (audioIsPlaying) return false; // already playing&#10;  if (!SD_MMC.begin()) {&#10;    Serial.println(&quot;[ERROR] SD_MMC not initialized&quot;);&#10;    return false;&#10;  }&#10;&#10;  audioFile = SD_MMC.open(path);&#10;  if (!audioFile) {&#10;    Serial.printf(&quot;[ERROR] Could not open file: %s\n&quot;, path);&#10;    return false;&#10;  }&#10;&#10;  uint32_t sampleRate = 44100;&#10;  uint16_t bitsPerSample = 16;&#10;  uint16_t channels = 1;&#10;  uint32_t dataOffset = 0;&#10;  uint32_t dataSize = 0;&#10;&#10;  if (!parseWavHeader(audioFile, sampleRate, bitsPerSample, channels, dataOffset, dataSize)) {&#10;    Serial.println(&quot;[ERROR] Unsupported or invalid WAV file&quot;);&#10;    audioFile.close();&#10;    return false;&#10;  }&#10;&#10;  // Re-open or seek to data offset&#10;  audioFile.seek(dataOffset);&#10;&#10;  // Configure I2S for built-in DAC&#10;  i2s_config_t i2s_config = {&#10;    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN),&#10;    .sample_rate = (int)sampleRate,&#10;    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,&#10;    .channel_format = (channels == 1) ? I2S_CHANNEL_FMT_ONLY_RIGHT : I2S_CHANNEL_FMT_RIGHT_LEFT,&#10;    .communication_format = I2S_COMM_FORMAT_I2S_MSB,&#10;    .intr_alloc_flags = 0,&#10;    .dma_buf_count = 4,&#10;    .dma_buf_len = 512,&#10;    .use_apll = false&#10;  };&#10;&#10;  esp_err_t err = i2s_driver_install(I2S_NUM_0, &amp;i2s_config, 0, NULL);&#10;  if (err != ESP_OK) {&#10;    Serial.printf(&quot;[ERROR] i2s_driver_install failed: %d\n&quot;, err);&#10;    audioFile.close();&#10;    return false;&#10;  }&#10;&#10;  i2s_set_dac_mode(I2S_DAC_CHANNEL_RIGHT_EN); // use right channel -&gt; DAC1&#10;  i2s_pin_config_t pin_config = {0};&#10;  i2s_set_pin(I2S_NUM_0, &amp;pin_config); // no pins for builtin DAC&#10;&#10;  // Start streaming task&#10;  uint32_t *arg = (uint32_t *)malloc(sizeof(uint32_t));&#10;  *arg = sampleRate;&#10;  BaseType_t x = xTaskCreatePinnedToCore(audioTask, &quot;audioTask&quot;, 4096, arg, 5, &amp;audioTaskHandle, 1);&#10;  if (x != pdPASS) {&#10;    Serial.println(&quot;[ERROR] Failed to create audio task&quot;);&#10;    audioFile.close();&#10;    stopI2S();&#10;    return false;&#10;  }&#10;&#10;  return true;&#10;}&#10;&#10;void stopPlayback() {&#10;  if (!audioIsPlaying) return;&#10;  audioStopRequested = true;&#10;  // wait for task to finish&#10;  int attempts = 0;&#10;  while (audioIsPlaying &amp;&amp; attempts++ &lt; 50) {&#10;    vTaskDelay(100 / portTICK_PERIOD_MS);&#10;  }&#10;  if (audioTaskHandle) {&#10;    // ensure task cleaned up&#10;    audioTaskHandle = nullptr;&#10;  }&#10;}&#10;&#10;bool isPlaying() {&#10;  return audioIsPlaying;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="#include &quot;../include/AudioPlayer.h&quot;&#10;&#10;#include &lt;Arduino.h&gt;&#10;#include &lt;SD_MMC.h&gt;&#10;#include &quot;driver/i2s.h&quot;&#10;#include &lt;esp_err.h&gt;&#10;&#10;static TaskHandle_t audioTaskHandle = nullptr;&#10;static File audioFile;&#10;static volatile bool audioStopRequested = false;&#10;static volatile bool audioIsPlaying = false;&#10;&#10;static bool parseWavHeader(File &amp;f, uint32_t &amp;sampleRate, uint16_t &amp;bitsPerSample, uint16_t &amp;channels, uint32_t &amp;dataOffset, uint32_t &amp;dataSize) {&#10;  // Minimal WAV header parsing&#10;  if (!f) return false;&#10;  f.seek(0);&#10;  char riff[4];&#10;  f.read((uint8_t *)riff, 4);&#10;  if (strncmp(riff, &quot;RIFF&quot;, 4) != 0) return false;&#10;  f.seek(8);&#10;  char wave[4];&#10;  f.read((uint8_t *)wave, 4);&#10;  if (strncmp(wave, &quot;WAVE&quot;, 4) != 0) return false;&#10;&#10;  // Find chunks&#10;  dataOffset = 0;&#10;  dataSize = 0;&#10;  sampleRate = 44100;&#10;  bitsPerSample = 16;&#10;  channels = 1;&#10;&#10;  while (f.position() &lt; f.size()) {&#10;    char chunkId[5] = {0};&#10;    if (f.read((uint8_t *)chunkId, 4) != 4) break;&#10;    uint32_t chunkSize = 0;&#10;    if (f.read((uint8_t *)&amp;chunkSize, 4) != 4) break;&#10;&#10;    if (strncmp(chunkId, &quot;fmt &quot;, 4) == 0) {&#10;      uint16_t audioFormat = 0;&#10;      f.read((uint8_t *)&amp;audioFormat, 2);&#10;      f.read((uint8_t *)&amp;channels, 2);&#10;      f.read((uint8_t *)&amp;sampleRate, 4);&#10;      // skip byte rate(4) and block align(2)&#10;      f.seek(f.position() + 6);&#10;      f.read((uint8_t *)&amp;bitsPerSample, 2);&#10;      // skip any extra fmt bytes&#10;      uint32_t remain = chunkSize - 16;&#10;      if (remain &gt; 0) f.seek(f.position() + remain);&#10;    } else if (strncmp(chunkId, &quot;data&quot;, 4) == 0) {&#10;      dataOffset = f.position();&#10;      dataSize = chunkSize;&#10;      // move to end of data chunk start (we already at start of data)&#10;      f.seek(f.position() + chunkSize);&#10;    } else {&#10;      // skip unknown chunk&#10;      f.seek(f.position() + chunkSize);&#10;    }&#10;  }&#10;&#10;  // basic validation&#10;  if (dataOffset == 0 || dataSize == 0) return false;&#10;  return true;&#10;}&#10;&#10;static void stopI2S() {&#10;  i2s_zero_dma_buffer(I2S_NUM_0);&#10;  i2s_driver_uninstall(I2S_NUM_0);&#10;}&#10;&#10;static void audioTask(void *arg) {&#10;  (void)arg; // arg unused&#10;&#10;  const size_t bufferSize = 1024;&#10;  uint8_t buffer[bufferSize];&#10;&#10;  audioIsPlaying = true;&#10;  audioStopRequested = false;&#10;&#10;  while (!audioStopRequested &amp;&amp; audioFile &amp;&amp; audioFile.available()) {&#10;    size_t toRead = min((size_t)audioFile.available(), bufferSize);&#10;    int readBytes = audioFile.read(buffer, toRead);&#10;    if (readBytes &lt;= 0) break;&#10;&#10;    // Write to I2S&#10;    size_t bytesWritten = 0;&#10;    esp_err_t res = i2s_write(I2S_NUM_0, buffer, readBytes, &amp;bytesWritten, portMAX_DELAY);&#10;    if (res != ESP_OK) break;&#10;  }&#10;&#10;  audioFile.close();&#10;  stopI2S();&#10;  audioIsPlaying = false;&#10;  audioTaskHandle = nullptr;&#10;  vTaskDelete(NULL);&#10;}&#10;&#10;bool audioInit() {&#10;  // nothing to init ahead of time; SD will be initialized in main&#10;  return true;&#10;}&#10;&#10;bool playFile(const char *path) {&#10;  if (audioIsPlaying) return false; // already playing&#10;  if (!SD_MMC.begin()) {&#10;    Serial.println(&quot;[ERROR] SD_MMC not initialized&quot;);&#10;    return false;&#10;  }&#10;&#10;  audioFile = SD_MMC.open(path);&#10;  if (!audioFile) {&#10;    Serial.printf(&quot;[ERROR] Could not open file: %s\n&quot;, path);&#10;    return false;&#10;  }&#10;&#10;  uint32_t sampleRate = 44100;&#10;  uint16_t bitsPerSample = 16;&#10;  uint16_t channels = 1;&#10;  uint32_t dataOffset = 0;&#10;  uint32_t dataSize = 0;&#10;&#10;  if (!parseWavHeader(audioFile, sampleRate, bitsPerSample, channels, dataOffset, dataSize)) {&#10;    Serial.println(&quot;[ERROR] Unsupported or invalid WAV file&quot;);&#10;    audioFile.close();&#10;    return false;&#10;  }&#10;&#10;  // Re-open or seek to data offset&#10;  audioFile.seek(dataOffset);&#10;&#10;  // Configure I2S for built-in DAC&#10;  i2s_config_t i2s_config = {&#10;    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN),&#10;    .sample_rate = (int)sampleRate,&#10;    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,&#10;    .channel_format = (channels == 1) ? I2S_CHANNEL_FMT_ONLY_RIGHT : I2S_CHANNEL_FMT_RIGHT_LEFT,&#10;    .communication_format = I2S_COMM_FORMAT_I2S_MSB,&#10;    .intr_alloc_flags = 0,&#10;    .dma_buf_count = 4,&#10;    .dma_buf_len = 512,&#10;    .use_apll = false&#10;  };&#10;&#10;  esp_err_t err = i2s_driver_install(I2S_NUM_0, &amp;i2s_config, 0, NULL);&#10;  if (err != ESP_OK) {&#10;    Serial.printf(&quot;[ERROR] i2s_driver_install failed: %d\n&quot;, err);&#10;    audioFile.close();&#10;    return false;&#10;  }&#10;&#10;  i2s_set_dac_mode(I2S_DAC_CHANNEL_RIGHT_EN); // use right channel -&gt; DAC1&#10;  i2s_pin_config_t pin_config = {0};&#10;  i2s_set_pin(I2S_NUM_0, &amp;pin_config); // no pins for builtin DAC&#10;&#10;  // Start streaming task&#10;  BaseType_t x = xTaskCreatePinnedToCore(audioTask, &quot;audioTask&quot;, 4096, NULL, 5, &amp;audioTaskHandle, 1);&#10;  if (x != pdPASS) {&#10;    Serial.println(&quot;[ERROR] Failed to create audio task&quot;);&#10;    audioFile.close();&#10;    stopI2S();&#10;    return false;&#10;  }&#10;&#10;  return true;&#10;}&#10;&#10;void stopPlayback() {&#10;  if (!audioIsPlaying) return;&#10;  audioStopRequested = true;&#10;  // wait for task to finish&#10;  int attempts = 0;&#10;  while (audioIsPlaying &amp;&amp; attempts++ &lt; 50) {&#10;    vTaskDelay(100 / portTICK_PERIOD_MS);&#10;  }&#10;  if (audioTaskHandle) {&#10;    // ensure task cleaned up&#10;    audioTaskHandle = nullptr;&#10;  }&#10;}&#10;&#10;bool isPlaying() {&#10;  return audioIsPlaying;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>